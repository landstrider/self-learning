String + Number
String -  Number

Remove Duplicates from array : Set()

Transpiring let to var and maintaining its block scope: IIFE

5<6<7, coercion of true
7>6>5

Fat arrow scope and why you should not use it

arguments(keyword) binding to arrow function
Alternative to it, spread operator

ASI(Automatic Semicolon Insertion) after return line break 

Not allow new properties to be added to an object. Object.freeze() and what else!
Change Property but not allow to add new property
Object.seal() and what else!
Be able to modify only specific properties
Object.defineProperty()

console.log(Math.max()); -Infinity, Why?

Operator Precedence:
&&    —> left associative(LA)
||   —> LA
? :    —> RA
=    —> RA
,

Statement and Expressions

Gotcha: typeof null === “object” —> returns true

Grammar#ExpressionSideEffect
Chained assignment Gotcha
var a=b=42 , this would not declare b directly:
But in fact, var a = b = 3; is actually shorthand for:
b = 3;
var a = b;
Depending on strict mode, that would either throw an error(ReferenceError: b is not defined) or create accidental global(see the Scope & Closures title of this series) 

console.log(0.1 + 0.2 == 0.3); (see TypesAndGrammar#Values#SmallDecimalValues title of this series)

Testing for Integers: (see TypesAndGrammar#Values#TestinfForIntegers title of this series)
(x ^ 0) === x;
which is also sufficiently robust to return false even if a non-numeric value such as a string or null is passed to the function.
(typeof x === 'number') && (x % 1 === 0)
(Math.round(x) === x;) Math.cel(), math.floor() too

Ticker, setTimeout() (see  Asynchrony: Now & Later)

console.log(false == '0')
console.log(false === '0')
Coercion of false???

Passing an array to the push() method of another array pushes that entire array as a single element onto the end of the array. 

+c here is showing the unary operator form (operator with only one operand) of the + operator. Instead of performing mathematic addition (or string concatenation -- see below), the unary + explicitly coerces its operand (c) to a number value.

Date To number
Another common usage of the unary + operator is to coerce a Date object into a number, because the result is the unix timestamp (milliseconds elapsed since 1 January 1970 00:00:00 UTC) representation of the date/time value.

Hoisting, this, error???

Operator associativity for < and >. It compares left to right, so 3 > 2 > 1 JavaScript translates to true > 1. true has value 1, so it then compares 1 > 1, which is false.

typeof undefined == typeof NULL
The expression will be evaluated to true, since NULL will be treated as any other undefined variable.
Note: JavaScript is CASE-SENSITIVE and here we are using NULL instead of null.

ReferenceError is Scope resolution-failure related, whereas TypeError implies that Scope resolution was successful, but that there was an illegal/impossible action attempted against the result.

There are two predominant models for how scope works. The first of these is by far the most common, used by the vast majority of programming languages. It's called Lexical Scope, and we will examine it in-depth. The other model, which is still used by some languages (such as Bash scripting, some modes in Perl, etc.) is called Dynamic Scope.

A wrapping function statement that starts with (function... as opposed to just function.... While this may seem like a minor detail, it's actually a major change. Instead of treating the function as a standard declaration, the function is treated as a function-expression.
In other words, (function foo(){ .. }) as an expression means the identifier foo is found only in the scope where the .. indicates, not in the outer scope. Hiding the name foo inside itself means it does not pollute the enclosing scope unnecessarily.

Where we declare variables is not relevant when using var, because they will always belong to the enclosing scope.

((
It's a very little known fact that JavaScript in ES3 specified the variable declaration in the catch clause of a try/catch to be block-scoped to the catch block.

For instance:

try {
ndefined(); // illegal operation to force an exception!
}
catch (err) {
	console.log( err ); // works!
}

console.log( err ); // ReferenceError: `err` not found
As you can see, err exists only in the catch clause, and throws an error when you try to reference it elsewhere.
))

Hoisting, which talks about declarations being taken as existing for the entire scope in which they occur.
However, declarations made with let will not hoist to the entire scope of the block they appear in. Such declarations will not observably "exist" in the block until the declaration statement.
{
   console.log( bar ); // ReferenceError!
   let bar = 2;
}

((
for (let i=0; i<10; i++) {
	console.log( i );
}

console.log( i ); // ReferenceError
Not only does let in the for-loop header bind the i to the for-loop body, but in fact, it re-binds it to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration.

Here's another way of illustrating the per-iteration binding behavior that occurs:

{
	let j;
	for (j=0; j-1<10; j++) {
		let i = j; // re-bound for each iteration!
		console.log( i );
	}
}
))

((
Function declarations are hoisted, as we just saw. But function expressions are not.

foo(); // not ReferenceError, but TypeError!
var foo = function bar() {
	// ...
};
))

Essentially whenever and wherever you treat functions (which access their own respective lexical scopes) as first-class values and pass them around, you are likely to see those functions exercising closure. Be that timers, event handlers, Ajax requests, cross-window messaging, web workers, or any of the other asynchronous (or synchronous!) tasks, when you pass in a callback function, get ready to sling some closure around!
